<!DOCTYPE html>
<html>
<head>
  <title>Earn Points</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body style="text-align:center; font-family:sans-serif;">
  <h2>üéØ Watch Ads & Earn Points</h2>
  <button onclick="watchAd(1)">‚ñ∂Ô∏è Task 1 (10 pts)</button><br><br>
  <button onclick="watchAd(2)">‚ñ∂Ô∏è Task 2 (15 pts)</button><br><br>
  <button onclick="watchAd(3)">‚ñ∂Ô∏è Task 3 (20 pts)</button>

  <script>
    function watchAd(taskId) {
      // Your ad script
      show_9754867('pop').then(() => {
        let reward = taskId === 1 ? 10 : taskId === 2 ? 15 : 20;
        Telegram.WebApp.sendData(JSON.stringify({task: taskId, points: reward}));
        alert("‚úÖ You earned " + reward + " points!");
      }).catch(() => {
        alert("‚ùå Ad failed. Try again.");
      });
    }
  </script>
</body>
</html>

import sqlite3
import json
from aiogram import Bot, Dispatcher, executor, types

API_TOKEN = "YOUR_BOT_TOKEN_HERE"  # <-- put your Telegram bot token
ADMIN_ID = 123456789                # <-- your Telegram ID for admin panel

bot = Bot(token=API_TOKEN)
dp = Dispatcher(bot)

# ---------------- DATABASE ----------------
def init_db():
    conn = sqlite3.connect("bot.db")
    cur = conn.cursor()
    cur.execute("""
    CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY,
        username TEXT,
        points INTEGER DEFAULT 0
    )
    """)
    cur.execute("""
    CREATE TABLE IF NOT EXISTS withdraw_requests (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        amount INTEGER,
        status TEXT DEFAULT 'pending'
    )
    """)
    conn.commit()
    conn.close()

def add_user(user_id, username):
    conn = sqlite3.connect("bot.db")
    cur = conn.cursor()
    cur.execute("INSERT OR IGNORE INTO users (user_id, username) VALUES (?, ?)", (user_id, username))
    conn.commit()
    conn.close()

def add_points(user_id, amount):
    conn = sqlite3.connect("bot.db")
    cur = conn.cursor()
    cur.execute("UPDATE users SET points = points + ? WHERE user_id = ?", (amount, user_id))
    conn.commit()
    conn.close()

def get_points(user_id):
    conn = sqlite3.connect("bot.db")
    cur = conn.cursor()
    cur.execute("SELECT points FROM users WHERE user_id = ?", (user_id,))
    res = cur.fetchone()
    conn.close()
    return res[0] if res else 0

def request_withdraw(user_id, amount):
    conn = sqlite3.connect("bot.db")
    cur = conn.cursor()
    cur.execute("INSERT INTO withdraw_requests (user_id, amount) VALUES (?, ?)", (user_id, amount))
    cur.execute("UPDATE users SET points = points - ? WHERE user_id = ?", (amount, user_id))
    conn.commit()
    conn.close()

def get_pending_withdraws():
    conn = sqlite3.connect("bot.db")
    cur = conn.cursor()
    cur.execute("""
        SELECT withdraw_requests.id, users.username, withdraw_requests.amount
        FROM withdraw_requests
        JOIN users ON withdraw_requests.user_id = users.user_id
        WHERE withdraw_requests.status = 'pending'
    """)
    res = cur.fetchall()
    conn.close()
    return res

def update_withdraw(req_id, status):
    conn = sqlite3.connect("bot.db")
    cur = conn.cursor()
    cur.execute("UPDATE withdraw_requests SET status = ? WHERE id = ?", (status, req_id))
    conn.commit()
    conn.close()

# ---------------- COMMANDS ----------------
@dp.message_handler(commands=["start"])
async def start(message: types.Message):
    add_user(message.from_user.id, message.from_user.username)
    kb = types.ReplyKeyboardMarkup(resize_keyboard=True)
    kb.add("üìã Tasks", "üí∞ Balance", "üèß Withdraw")
    if message.from_user.id == ADMIN_ID:
        kb.add("üõ† Admin Panel")
    await message.answer("üöÄ Welcome! Earn points by completing tasks.", reply_markup=kb)

@dp.message_handler(lambda m: m.text == "üìã Tasks")
async def tasks(message: types.Message):
    webapp = types.WebAppInfo(url="https://YOUR_LOCAL_OR_PUBLIC_URL/ads.html")
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("üéØ Open Tasks", web_app=webapp))
    await message.answer("üìã Complete tasks to earn points!", reply_markup=kb)

@dp.message_handler(lambda m: m.text == "üí∞ Balance")
async def balance(message: types.Message):
    points = get_points(message.from_user.id)
    await message.answer(f"üí∞ You currently have {points} points!")

@dp.message_handler(lambda m: m.text == "üèß Withdraw")
async def withdraw(message: types.Message):
    points = get_points(message.from_user.id)
    if points < 10:
        await message.answer("‚ö†Ô∏è Minimum withdraw is 10 points.")
    else:
        request_withdraw(message.from_user.id, 10)
        await message.answer("‚úÖ Withdraw request sent (10 points). Admin will review.")

# ---------------- ADMIN ----------------
@dp.message_handler(lambda m: m.text == "üõ† Admin Panel")
async def admin_panel(message: types.Message):
    if message.from_user.id != ADMIN_ID:
        return
    withdraws = get_pending_withdraws()
    if not withdraws:
        await message.answer("‚úÖ No pending withdraw requests.")
        return
    for req_id, username, amount in withdraws:
        kb = types.InlineKeyboardMarkup()
        kb.add(
            types.InlineKeyboardButton("‚úÖ Approve", callback_data=f"approve_{req_id}"),
            types.InlineKeyboardButton("‚ùå Deny", callback_data=f"deny_{req_id}")
        )
        await message.answer(f"üë§ User: @{username}\nüíµ Amount: {amount}\nüìå Status: pending", reply_markup=kb)

@dp.callback_query_handler(lambda c: c.data.startswith("approve_") or c.data.startswith("deny_"))
async def process_withdraw_callback(callback: types.CallbackQuery):
    if callback.from_user.id != ADMIN_ID:
        return
    action, req_id = callback.data.split("_")
    req_id = int(req_id)
    if action == "approve":
        update_withdraw(req_id, "approved")
        await callback.message.edit_text("‚úÖ Withdraw Approved!")
    elif action == "deny":
        update_withdraw(req_id, "denied")
        await callback.message.edit_text("‚ùå Withdraw Denied!")
    await callback.answer()

# ---------------- WEBAPP DATA ----------------
@dp.message_handler(content_types="web_app_data")
async def webapp_points(message: types.Message):
    data = json.loads(message.web_app_data.data)
    points = data.get("points", 0)
    add_points(message.from_user.id, points)
    balance = get_points(message.from_user.id)
    await message.answer(f"üéâ You earned {points} points!\nüí∞ Balance: {balance}")

# ---------------- MAIN ----------------
if __name__ == "__main__":
    init_db()
    executor.start_polling(dp, skip_updates=True)
