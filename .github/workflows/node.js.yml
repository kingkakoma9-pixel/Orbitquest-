import sqlite3
import json
from aiogram import Bot, Dispatcher, executor, types

API_TOKEN = "YOUR_BOT_TOKEN_HERE"  # <-- put your Telegram bot token
ADMIN_ID = 123456789                # <-- your Telegram ID for admin panel

bot = Bot(token=API_TOKEN)
dp = Dispatcher(bot)

# ---------------- DATABASE ----------------
def init_db():
    conn = sqlite3.connect("bot.db")
    cur = conn.cursor()
    cur.execute("""
    CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY,
        username TEXT,
        points INTEGER DEFAULT 0
    )
    """)
    cur.execute("""
    CREATE TABLE IF NOT EXISTS withdraw_requests (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        amount INTEGER,
        status TEXT DEFAULT 'pending'
    )
    """)
    conn.commit()
    conn.close()

def add_user(user_id, username):
    conn = sqlite3.connect("bot.db")
    cur = conn.cursor()
    cur.execute("INSERT OR IGNORE INTO users (user_id, username) VALUES (?, ?)", (user_id, username))
    conn.commit()
    conn.close()

def add_points(user_id, amount):
    conn = sqlite3.connect("bot.db")
    cur = conn.cursor()
    cur.execute("UPDATE users SET points = points + ? WHERE user_id = ?", (amount, user_id))
    conn.commit()
    conn.close()

def get_points(user_id):
    conn = sqlite3.connect("bot.db")
    cur = conn.cursor()
    cur.execute("SELECT points FROM users WHERE user_id = ?", (user_id,))
    res = cur.fetchone()
    conn.close()
    return res[0] if res else 0

def request_withdraw(user_id, amount):
    conn = sqlite3.connect("bot.db")
    cur = conn.cursor()
    cur.execute("INSERT INTO withdraw_requests (user_id, amount) VALUES (?, ?)", (user_id, amount))
    cur.execute("UPDATE users SET points = points - ? WHERE user_id = ?", (amount, user_id))
    conn.commit()
    conn.close()

def get_pending_withdraws():
    conn = sqlite3.connect("bot.db")
    cur = conn.cursor()
    cur.execute("""
        SELECT withdraw_requests.id, users.username, withdraw_requests.amount
        FROM withdraw_requests
        JOIN users ON withdraw_requests.user_id = users.user_id
        WHERE withdraw_requests.status = 'pending'
    """)
    res = cur.fetchall()
    conn.close()
    return res

def update_withdraw(req_id, status):
    conn = sqlite3.connect("bot.db")
    cur = conn.cursor()
    cur.execute("UPDATE withdraw_requests SET status = ? WHERE id = ?", (status, req_id))
    conn.commit()
    conn.close()

# ---------------- COMMANDS ----------------
@dp.message_handler(commands=["start"])
async def start(message: types.Message):
    add_user(message.from_user.id, message.from_user.username)
    kb = types.ReplyKeyboardMarkup(resize_keyboard=True)
    kb.add("ðŸ“‹ Tasks", "ðŸ’° Balance", "ðŸ§ Withdraw")
    if message.from_user.id == ADMIN_ID:
        kb.add("ðŸ›  Admin Panel")
    await message.answer("ðŸš€ Welcome! Earn points by completing tasks.", reply_markup=kb)

@dp.message_handler(lambda m: m.text == "ðŸ“‹ Tasks")
async def tasks(message: types.Message):
    webapp = types.WebAppInfo(url="https://YOUR_LOCAL_OR_PUBLIC_URL/ads.html")
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("ðŸŽ¯ Open Tasks", web_app=webapp))
    await message.answer("ðŸ“‹ Complete tasks to earn points!", reply_markup=kb)

@dp.message_handler(lambda m: m.text == "ðŸ’° Balance")
async def balance(message: types.Message):
    points = get_points(message.from_user.id)
    await message.answer(f"ðŸ’° You currently have {points} points!")

@dp.message_handler(lambda m: m.text == "ðŸ§ Withdraw")
async def withdraw(message: types.Message):
    points = get_points(message.from_user.id)
    if points < 10:
        await message.answer("âš ï¸ Minimum withdraw is 10 points.")
    else:
        request_withdraw(message.from_user.id, 10)
        await message.answer("âœ… Withdraw request sent (10 points). Admin will review.")

# ---------------- ADMIN ----------------
@dp.message_handler(lambda m: m.text == "ðŸ›  Admin Panel")
async def admin_panel(message: types.Message):
    if message.from_user.id != ADMIN_ID:
        return
    withdraws = get_pending_withdraws()
    if not withdraws:
        await message.answer("âœ… No pending withdraw requests.")
        return
    for req_id, username, amount in withdraws:
        kb = types.InlineKeyboardMarkup()
        kb.add(
            types.InlineKeyboardButton("âœ… Approve", callback_data=f"approve_{req_id}"),
            types.InlineKeyboardButton("âŒ Deny", callback_data=f"deny_{req_id}")
        )
        await message.answer(f"ðŸ‘¤ User: @{username}\nðŸ’µ Amount: {amount}\nðŸ“Œ Status: pending", reply_markup=kb)

@dp.callback_query_handler(lambda c: c.data.startswith("approve_") or c.data.startswith("deny_"))
async def process_withdraw_callback(callback: types.CallbackQuery):
    if callback.from_user.id != ADMIN_ID:
        return
    action, req_id = callback.data.split("_")
    req_id = int(req_id)
    if action == "approve":
        update_withdraw(req_id, "approved")
        await callback.message.edit_text("âœ… Withdraw Approved!")
    elif action == "deny":
        update_withdraw(req_id, "denied")
        await callback.message.edit_text("âŒ Withdraw Denied!")
    await callback.answer()

# ---------------- WEBAPP DATA ----------------
@dp.message_handler(content_types="web_app_data")
async def webapp_points(message: types.Message):
    data = json.loads(message.web_app_data.data)
    points = data.get("points", 0)
    add_points(message.from_user.id, points)
    balance = get_points(message.from_user.id)
    await message.answer(f"ðŸŽ‰ You earned {points} points!\nðŸ’° Balance: {balance}")

# ---------------- MAIN ----------------
if __name__ == "__main__":
    init_db()
    executor.start_polling(dp, skip_updates=True)

